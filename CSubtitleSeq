public class CSubtitleSeq implements SubtitleSeq {

	private LinkedList<Subtitle> subList;
	
	private int transferToMS(Time time) { // this method transfer the time to millisecond						
		return (time.getHH() * 3600000) + (time.getMM() * 60000) + (time.getSS() * 1000) + (time.getMS());
	}

	@Override
	public void addSubtitle(Subtitle st) {
		int stStart=transferToMS(st.getStartTime());
		int stEnd=transferToMS(st.getEndTime());
		int size =0;
		if(subList.empty()){
			subList.insert(st);
		}else subList.findFirst(); 
		 
		if(stEnd<transferToMS(subList.retrieve().getStartTime())){
			Subtitle tmp=subList.retrieve();
			subList.insert(st);
			subList.findFirst();
			subList.update(st);
			subList.findNext();
			subList.update(tmp);
		}else{
			subList.findFirst();
			
			while (!subList.last()){
				subList.findNext();
                size++;
			}
			 size++;
			 
			int subEnd=transferToMS(subList.retrieve().getEndTime());
			if(stStart>subEnd){
				subList.insert(st);
			}else{
				subList.findFirst();
				
			for(int i=0;i<size;i++){
				int subEnd1=transferToMS(subList.retrieve().getEndTime());//there is a problem
				if(stStart>subEnd1){
					subList.findNext();
				int subStart1=transferToMS(subList.retrieve().getStartTime());
				if(stEnd<subStart1){
					subList.findFirst();
					for(int j=0;j<i;j++){
						subList.findNext();
					}
					subList.insert(st);
					return;
				}	
				}
//				subList.findNext();
			}
			}
		}
		
		
	}



	@Override
	public List<Subtitle> getSubtitles() {
		// TODO Auto-generated method stub
		return subList;
	}

	@Override
	public Subtitle getSubtitle(Time time) {

		subList.findFirst();

		while (!subList.last()){
			if(subList.retrieve().getStartTime().equals(time)||subList.retrieve().getEndTime().equals(time))
				return subList.retrieve();
			else {
				subList.findNext();  
			}
		
		}
		if(subList.retrieve().getStartTime().equals(time)||subList.retrieve().getEndTime().equals(time))
			return subList.retrieve();
		
		return null;
	}

	

	@Override
	public List<Subtitle> getSubtitles(Time startTime, Time endTime) {
		// SpSub means the list that contains the subtitles between the
		// specified time
		LinkedList<Subtitle> spSub = new LinkedList<Subtitle>();
		subList.findFirst();
		int startTimeMS = transferToMS(startTime);// transfer the time of
													// startTime to millisecond
		int endTimeMS = transferToMS(endTime);// transfer the time of endTime to
												// millisecond
		while (!subList.last()) {
			int st = transferToMS(subList.retrieve().getStartTime());// transfer start time in the list  to  millisecond
			int et = transferToMS(subList.retrieve().getEndTime());// transfer end time in the list to millisecond
			if (st >= startTimeMS && et <= endTimeMS) {
				spSub.insert(subList.retrieve());
				subList.findNext();
			}

		}

		return spSub;
	}

	@Override
	public List<Subtitle> getSubtitles(String str) {
		// TODO Auto-generated method stub
		subList.findFirst();
		LinkedList<Subtitle> spSub = new LinkedList<Subtitle>();

		while (!subList.last()) {
			if (subList.retrieve().getText().contains(str)) {
				spSub.insert(subList.retrieve());
			}
			subList.findNext();
		}
		if (subList.retrieve().getText().contains(str)) {
			spSub.insert(subList.retrieve());
		}
		return spSub;
	}

	@Override
	public void remove(String str) {
		// TODO Auto-generated method stub
		subList.findFirst();
		while (!subList.last()) {
			if (subList.retrieve().getText().contains(str)) {
				subList.remove();
			}
			subList.findNext();
		}
		if (subList.retrieve().getText().contains(str)) {
			subList.remove();
		}
	}

	@Override
	public void replace(String str1, String str2) {
		// TODO Auto-generated method stub
		subList.findFirst();
		
		while(!subList.last()){
			if(subList.retrieve().getText().contains(str1))
				subList.retrieve().getText().replaceAll(str1, str2);
			subList.findNext();
		}
		if(subList.retrieve().getText().contains(str1))
			subList.retrieve().getText().replaceAll(str1, str2);
		
	}


	@Override
	public void shift(int offset) {
		subList.findFirst();

		while (!subList.last()) {
			int StartTime = transferToMS(subList.retrieve().getStartTime());
			int EndTime = transferToMS(subList.retrieve().getEndTime());
			StartTime += offset;
			EndTime += offset;
			if (EndTime == 0)
				subList.remove();

			if (StartTime < 0) {
				StartTime = 0;
			} else if (EndTime < 0) {
				EndTime = 0;
			}
			subList.findNext();
		}
		int StartTime = transferToMS(subList.retrieve().getStartTime());
		int EndTime = transferToMS(subList.retrieve().getEndTime());
		StartTime += offset;
		EndTime += offset;
		if (EndTime == 0)
			subList.remove();
	}

	@Override
	public void cut(Time startTime, Time endTime) {
		subList.findFirst();
		
		int STM = transferToMS(startTime); // Given Start time to miliseconds
		int ETM = transferToMS(endTime); // Given End time to miliseconds
		int Gap = 0;
		while(!subList.last()){
			int subST = transferToMS(subList.retrieve().getStartTime());
			int subET = transferToMS(subList.retrieve().getEndTime());
			Gap += (subET - subST);
			if(subST >= STM || subET <= ETM){
				subList.remove();
			}
			subList.findNext();
		}
		
		int subST = transferToMS(subList.retrieve().getStartTime());
		int subET = transferToMS(subList.retrieve().getEndTime());
		Gap += (subET - subST);
		if(subST >= STM || subET <= ETM){
			subList.remove();
		}
		shift(Gap);
	}
}
